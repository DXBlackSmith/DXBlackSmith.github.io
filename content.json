{"meta":{"title":"Hexo","subtitle":"","description":"","author":"DxBlackSmith","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2026-01-13T09:57:44.000Z","updated":"2026-01-13T09:58:17.610Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2026-01-13T10:42:48.000Z","updated":"2026-01-13T10:46:21.352Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"烤面筋 Day 02","slug":"烤面筋_Day02","date":"2026-01-14T07:13:34.486Z","updated":"2026-01-14T07:34:33.798Z","comments":true,"path":"2026/01/14/烤面筋_Day02/","permalink":"http://example.com/2026/01/14/%E7%83%A4%E9%9D%A2%E7%AD%8B_Day02/","excerpt":"","text":"烤面筋 Day 02 类型转换1. 向上转型 vs 向下转型?这是多态中两个方向完全相反的操作： 向上转型： 定义：将子类的指针或引用转换成父类 安全性：绝对安全。因为子类也是一种父类 用法：这种转换是隐式，不需要显式调用 static_cast ，是实现多态的基础 向下转型： 定义：将父类的指针或引用转换为子类。 安全性： 不安全。父类对象不一定是子类。 用法：必须使用显式转换，出于安全保证使用 dynamic_cast 2. static_cast 与 dynamic_cast 的区别？本质区别在于 “转换发生的时机” 和 “安全检查的机制” static_cast： 在编译阶段完成，不进行运行时类型检查 主要用于基本类型转换（如 int 转 float），非多态层级结构内的指针&#x2F;引用转换。 dynamic_cast： 在运行阶段利用 RTTI（运行时类型信息） 检查转换是否合法 专门用于处理**多态（Polymorphism）**层级结构中的转换 3. static_cast 在什么场景有风险？static_cast 的风险主要发生在 向下转型（Downcasting），即把基类指针转换为派生类指针时： 风险点： 如果该基类指针实际上并没有指向那个派生类对象，static_cast 依然会强行转换成功，返回一个地址。 后果： 当你通过这个转换后的指针访问派生类特有的成员变量或虚函数时，会发生未定义行为（Undefined Behavior），通常表现为内存越界访问或程序崩溃，且这种错误在编译期无法察觉。 4. dynamic_cast 的优势是什么？它的核心优势是 “安全性”： 类型安全检查： 它会检查目标类型是否与对象的实际类型匹配。如果转换非法，对于指针会返回 nullptr，对于引用会抛出 std::bad_cast 异常。 支持虚继承转换： 在复杂的深层或菱形继承中，dynamic_cast 能够正确处理指针偏移。 Reactor + 线程池1. Reactor 模式是怎么实现的？Reactor 模式本质上是 “I&#x2F;O 复用 + 派发”，其核心组件包括： Event Demultiplexer：底层通常是 epoll或者 iocp ，监听注册了的一堆文件描述符有哪些动静 Reactor：核心循环。通过多路分离器等待事件发生，一旦有事件（如可读、可写），就将其分发（Dispatch）给对应的 Handler。 Handlers：绑定在事件上的回调函数，负责非阻塞的读写操作。 2. 为什么采用主从 Reactor + 线程池？主要是为了解决单线程 Reactor 的性能瓶颈： 分工明确：Main Reactor 只负责监听连接（Accept），Sub Reactor 负责处理已连接套接字的 I&#x2F;O 事件。这避免了因为某个请求的 I&#x2F;O 耗时过长导致新连接无法进入。 充分利用多核： 多个 Sub Reactor 可以运行在不同的 CPU 核心上，并行处理 I&#x2F;O。 解耦计算：线程池 将业务计算逻辑从 I&#x2F;O 线程中剥离。如果业务逻辑耗时较长，它不会阻塞 I&#x2F;O 事件的分发，从而极大提高了系统的吞吐量。 Ps. 这里的 I&#x2F;O 线程处理的是 I&#x2F;O 读写，指的是从网卡驱动缓存拷贝到用户缓存区，或者将用户态数据拷贝到内核发送缓存区。业务计算逻辑则是加工数据（数据读上来以后，程序需要处理它），例如协议解析（二进制流解包成 Protobuf 或 JSON），数据库查询（根据请求差 SQL）等等 3. CPU 密集型和 I&#x2F;O 密集型怎么判断？主要是看瓶颈在哪里：$N_{cpu}$ 是 CPU 核心数的意思 CPU 密集型： 特点：大部分时间在做复杂的运算（图像处理、科学计算） 判断： 程序运行时，CPU 占用率极高，但几乎没有磁盘或网络 I&#x2F;O。 线程池策略： 线程数通常设置为 $N_{CPU} + 1$。 I&#x2F;O 密集型： 特点： 大部分时间在等待磁盘读写、数据库查询、网络响应。 判断： CPU 占用率较低，系统大量时间处于等待状态（Wait）。 线程池策略： 线程数可以设置得大一些，如 $2N_{CPU}$ 甚至更多。 4. 线程池线程数如何确定？首先针对于 I&#x2F;O 密集型任务来说，一般设置为内核数 * 2。 当一个线程因为 I&#x2F;O 阻塞或等待时，CPU 可以切换到另一个线程。避免过多的上下文切换（Context Switch）带来的损耗。 不过在实际生产环境下，我会优先通过 压力测试 和 性能监控（如查看 top 中的 iowait 指标）来动态调整线程数，而不会死守 公式。","categories":[{"name":"C++ 面经","slug":"C-面经","permalink":"http://example.com/categories/C-%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"烤面筋 Day 01","slug":"烤面筋_Day01","date":"2026-01-13T10:14:19.695Z","updated":"2026-01-14T07:11:17.577Z","comments":true,"path":"2026/01/13/烤面筋_Day01/","permalink":"http://example.com/2026/01/13/%E7%83%A4%E9%9D%A2%E7%AD%8B_Day01/","excerpt":"","text":"烤面筋 Day 01 原子操作与内存模型: 1. 原子操作是什么？Atomic 跟原子操作的关系是什么？答：原子操作就是要么不执行，要么全部执行成功，且中途不能被中断的操作。Atomic 就是 C++ 11 提供的标准库模板类，是原子操作在语言层面的封装和工具。 2. Atomic 底层是怎么实现的？答：底层主要依赖硬件层面处理器提供的原子指令，在 x86 架构下，通常会使用带有 LOCK 前缀的指令，其能锁定缓存行，确保执行执行期间不会被中断。 编译器层面也会根据不同的 CPU 架构，将 atomic 操作映射为相应的机器指令，根据指定的内存序，插入必要的 Memory Barrier ，防止指令重排。 3. 能简单讲讲 C++ 的内存序（Memory Order）吗？内存序的作用是约束编译器和 CPU 的指令重排优化，C++11 定义了 6 种内存序，但常用的是 memory_order_relaxed 和 获取&#x2F;释放语义和序列一致性。 宽松顺序：只保证当前操作的原子性，不保证任何顺序（没有同步关系）。 释放（release）语义：持有 release 的线程是发布者，，逻辑是 “做完手头的事情了，现在发布表示数据准备好了” 获取（acquire）语义：持有 acquire 的线程是获取者，逻辑是 “看到发布的通知了，说明我可以放心去用数据了” 序列一致性：atomic 的默认参数，要求所有线程看到的执行顺序都是一模一样的，就像所有操作都排在一个全局队列里依次执行。 那为什么不能全用默认的 seq_cst 序列一致性的内存序？ 高性能场景下（如无锁队列、底层驱动），默认的强顺序会导致大量的内存屏障指令，强制刷新 CPU 缓存，这会极大限制现代多核处理器的并行能力。 4. CAS 指令是什么？答：CAS 是实现原子操作的核心指令，包含三个操作数： 1231. 内存地址 V：要读取的变量位置。2. 旧的预期值 A：我们认为该变量当前应该是什么值。3. 准备写入的新值 B：如果检查通过，要更新成的值。 只有内存地址的值还是我之前读到的那个预期值，我才把它修改成新值。否则说明别人改过它，那我就放弃这次修改。整个过程是原子性的 5.CAS 的优缺点是什么？答：优点就是无锁，避免了传统互斥锁导致的线程上下文切换、挂起和恢复，性能开销更小。 缺点是有自旋开销，如果在高竞争环境下，CAS 一直失败，会导致 CPU 一直空转，浪费资源。同时还存在 ABA 问题。 6. ABA 问题是什么？如何解决这个问题？就是一个线程将数值 A 改成了 B，随后另一个线程又将 B 改回了 A，此时第三个线程进行检查，发现值依然是 A，认为没有改变，从而误操作。 目前解决的主流办法是版本号，实现方法就是记录值的同时维护一个版本号，每次更新的时候，不仅更新值，还让版本号 +1。这样遇到 ABA 问题的时候版本号不同，就知道值已经发生改变了。 7. C++ atomic 是否自带版本号机制？不自带。标准的 std::atomic 只是对类型 T 的原子封装。如果 T 是一个指针，仍然会存在 ABA 问题。 如果需要解决这个问题的话，开发者通常需要配合 std::atomic&lt;std::pair&lt;T, int&gt;&gt; 或者一些带有 Tag 的指针技术。 8. Volatile 关键字的作用是什么？能解决线程安全吗？主要的作用是禁止编译器优化：告诉编译器，这个变量的值可能随时被外部（如硬件中断、另一个进程）修改，因此每次使用它都必须从内存中读取，而不能使用寄存器里的缓存。 不能，因为他不保证原子性，同时不禁止指令重排，只针对编译器的，但不提供针对 CPU 的内存屏障，无法解决多核环境下的可见性和有序性问题。 9. 手撕一下：写一下 CAS 实现的无锁队列1234567891011121314151617181920212223242526272829303132333435#include &lt;atomic&gt;template &lt;typename T&gt;class LockFreeQueue &#123;public: void Enqueue(const T&amp; val) &#123; Node* new_node = Node(val); Node* old_tail = tail.load(); while(true) &#123; old_tail = tail.load(); Node* next = old_tail-&gt;next.load(); if(old_tail == tail.load()) &#123; if(next == nullptr) &#123; if(old_tail-&gt;next.compare_exchange_strong(next, new_node)) &#123; tail.compare_exchange_weak(old_tail, new_node); return; &#125; &#125; else tail.compare_exchange_strong(old_tail, next); &#125; &#125; &#125;private: struct Node &#123; T data; std::atomic&lt;Node*&gt; next; Node(T val) : data(val), next(nullptr) &#123;&#125; &#125;; std::atomic&lt;Node*&gt; head; std::atomic&lt;Node*&gt; tail;&#125;;int main(int argc, char* argv[]) &#123;&#125; 多线程与锁 1. 多线程最常见的问题是什么？主要是三个问题： 线程安全问题：多个线程同时读写同一个块内存，导致结果不可预期 活跃性问题：包括死锁，活锁和饥饿，其中死锁是最致命的，会导致程序完全卡死 性能开销：过渡的上下文切换和锁竞争导致性能下降 2. 死锁怎么避免？避免死锁的核心逻辑是：防止循环等待链的形成。常用的解决办法如下： 固定加锁顺序：规定所有的线程必须按照相同的顺序获取锁（先拿 A 锁，再拿 B 锁） 尝试锁（Try-lock）：使用 std::unique_lock 的 try_lock，如果拿不到锁就立即释放已占用的所并且回退 使用高级抽象：使用其他无锁的机制（比如消息传递等等）来替代底层锁 3. 哪些设计方式&#x2F;技巧能破坏死锁的 4 个条件？互斥性：资源一次只能被一个线程占用。这个是无法破坏（锁的本意）。 占用且等待：线程持有一个资源的同时，还在等待另一个资源。采用一次性申请的方式解决： 线程启动前一次性申请所有需要的锁；或者在无法获取下一个锁时，释放已占有的所有锁。 不可剥夺：资源不能被抢占，只能由持有者主动释放。采用抢占机制的方式解决：如果线程申请新锁失败，主动释放手中资源，过段时间再重试 循环等待：存在一个线程等待环路：T1 等 T2，T2 等 T1。采用资源线性排序的方式解决： 给所有锁分配唯一序号，强制规定必须按序号从小到大（或从大到小）获取锁。 4. 实际开发中，你会如何实现避免死锁的发生？我会使用 std::scoped_lock 一次性添加多个锁利用其内部的机制来避免 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;thread&gt;class Account &#123;public: int balance = 1000; std::mutex mtx; // 每个账户自带一把锁&#125;;void transfer(Account&amp; from, Account&amp; to, int amount) &#123; // 关键点：std::scoped_lock 同时接收多个 mutex // 它内部使用了一种免死锁算法（通常是逐个尝试且不持有等待） // 无论你传入参数的顺序如何，它都能保证不会发生死锁 std::scoped_lock lock(from.mtx, to.mtx); if (from.balance &gt;= amount) &#123; from.balance -= amount; to.balance += amount; std::cout &lt;&lt; &quot;转账成功: &quot; &lt;&lt; amount &lt;&lt; std::endl; &#125;&#125;int main() &#123; Account alice, bob; // 线程 1：从 Alice 转账给 Bob std::thread t1(transfer, std::ref(alice), std::ref(bob), 100); // 线程 2：从 Bob 转账给 Alice (如果用普通 lock 会因顺序相反导致死锁) std::thread t2(transfer, std::ref(bob), std::ref(alice), 200); t1.join(); t2.join(); return 0;&#125; 其内部的机制 避免循环等待：内部并不简单地按顺序调用 lock()，而是采用了一种 “重试机制”： ​ 1. 它会尝试锁住第一个互斥量。 ​ 2. 接着尝试 try_lock 后面的互斥量。 ​ 3. 如果中间任何一个锁失败了，它会立即释放已经持有的所有锁，然后重新开始。 原子性加锁：保证了所有传入的互斥量要么全部锁住，要么一个都不锁。","categories":[{"name":"C++ 面经","slug":"C-面经","permalink":"http://example.com/categories/C-%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"NetWork","slug":"NetWork","date":"2025-12-07T05:09:21.000Z","updated":"2026-01-13T10:47:08.037Z","comments":true,"path":"2025/12/07/NetWork/","permalink":"http://example.com/2025/12/07/NetWork/","excerpt":"","text":"“连网”平时我们说的连网，连网到底是什么呢？为什么实验室的主机只能接网线或者连接 wifi 才能访问互联网上的各种资源呢？ 为了搞清楚这个问题，需要搞懂下面几个概念 连网：主机通过有线或无线方式接入网络，获得 IP 地址，并能够与其他设备或互联网进行数据通信的过程。 主机网络通信的方法公网通信两台主机都有公网 IP, 可以直接通过 ssh user@公网 IP 连接 这种通常只适用于具有固定公网 IP 的设备连接。 家庭的宽带通常是动态的公网 IP (重启光猫以后会变化)，企业或者云服务器才是静态公网 IP 。 解释家里为什么只有连接 wifi （连接路由器）才能访问互联网上的各种资源。 只要是需要访问互联网上的资源，那么都需要设备具有公网 IP， 但是手机等设备出厂时只有 mac 地址，连接路由器的才会给你分配 IP 地址（IP 地址是逻辑地址，由网络环境决定的），但是就算给你分配了，也只是内网 IP，路由器才是唯一具有公网 IP 的设备。 不过连接的路由器会将你的内网 IP 结合自己的 WAN 口（公网 IP）转换成公网 IP，收到回复包的时候，又将这个公网 IP 转换成内网 IP 从而找到你的设备，这其中牵扯到的协议叫做 NAT 协议，这里先不仔细讲了，大概是实现了地址转换的意思。 Ps. 用 4G/5G 是不经过家用路由器，直接通过基站连接到运营商的核心网，然后运营商给你分配 CGNAT IP&#x2F; 公网 IP 。 局域网通信同一局域网内通信在同一局域网下面，通过局域网的 IP 能够直接进行通信。这个用的比较多，一般公司&#x2F;学校&#x2F;实验室内部服务器都是通过这种方式。 那么有些时候为了固定比如监控摄像头和打印机的 IP 或者实验室根本就没有路由器（纯内网通信），这个时候作为计算机专业的我们，可能会让我们配置静态 IP。 于是就会接触下面的概念： 子网掩码：用于划分网络地址和主机地址。同一局域网的所有 IP &amp; 上这个掩码都会得到同一个地址（一般就填 255.255.255.0 ） 默认网关：当访问不是局域网的地址的时候，数据包就会发给网关。通常是路由器的内网 IP ，大多数默认网关的 IP 地址的最后一位是 1 或者 254（0 不可以，255 用作广播） DNS 服务器：用于将输入的域名解析成 IP 地址，比较方便。DNS 服务器通常填 114.114.114.114 这种公共 DNS 服务器即可 在纯内网通信（实验室中常用）当中，交换机由于没有 DHCP 服务器，就没有自动分配 IP 的功能（路由器有），所以这个时候只能通过手动配置 IP 的方式来实现通信。 这个时候只需要所有的机器都在同一个网段，比如 12345678910IP: 不冲突就行 机器 A : 192.168.10.10 机器 B : 192.168.10.11 机器 B : 192.168.10.12 子网掩码： 统一填 255.255.255.0 默认网关: 一般留空（0.0.0.0)，因为一般不需要上网DNS： 一般也留空，除非你要解析域名，但是一般内网用 IP 地址 如何配置一个新设备的静态 IP 记录同网段下另一台配置好得设备的网段 （IP + 子网掩码 192.168.31.0&#x2F;24）和默认网关（ 192.168.31.1） 选择一个不冲突的静态 IP（ping 一下看看连不连通），登录设备的管理界面，这个一般根据设备的不同有些许不同，可以查看下表： 设备类型 登录方式 打印机 1. 在打印机面板上查看 IP 2. 用浏览器访问该 IP 3. 输入管理员账号密码（默认常印在机身） 交换机（网管型） 1. 用 Console 线（串口）连接电脑 2. 用终端软件（PuTTY、SecureCRT）登录 摄像头 &#x2F; NAS 浏览器访问 IP 或专用客户端 Linux 服务器 SSH 登录后修改网络配置文件 配置 IP 参数（一般内网就配置 IP 地址和子网掩码就可以）同时保存验证，比如用新 IP 能够重新访问设备的管理界面和用其他设备 ping 一下这个设备来测试连通。 不同局域网之间通信 通过跳板机中转 跳板机：一个专门用于中转访问内网资源的 “堡垒” 服务器，一般用于集中管理访问权限。 比如公司的数据库服务器，或者内部的 API 服务部署在私有网络中，处于安全考虑不允许直接暴露到互联网中。所以他们没有公网 IP，同时又不可能和你在一个局域网内，这个时候就需要先登录一台有公网 IP 的跳板机，再从它跳转过去。 这样目标服务器就实现了完全隔离，其防火墙只允许跳板机 IP 访问 SSH 端口。 那么我们如何能够通过跳板机来连接目标服务器呢？ 最推荐的就是直接编辑本地电脑的 SSH 配置文件（~&#x2F;.ssh&#x2F;config 文件）。假如我们有如下信息 角色 信息 跳板机 公网 IP: 203.0.113.10，用户名: abc，SSH 端口: 22 目标服务器 内网 IP: 10.0.1.20，用户名: cba 那么直接在配置文件中定义如下即可： 1234567891011# 跳板机定义Host jump HostName 203.0.113.10 User ops Port 22# 目标服务器（通过跳板机访问）Host db-server HostName 10.0.1.20 User app ProxyJump jump vscode 下载相应的插件以后读取这个配置，就能直接连接内部服务器，实现代码编辑和文件上传（vscode 内置的 SFTP ）。也有人用 xftp 或者 Filezilla 来实现文件传输，我没用过，所以暂时不评论。 Ps. vscode 具体操作就是调出命令面板，remote-ssh: connet to host。 内网穿透 这个暂时没有接触到，先挖个坑。。。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"Hot 100 刷题记录","slug":"Hot100 记录","date":"2025-01-13T10:05:08.000Z","updated":"2026-01-13T10:47:24.358Z","comments":true,"path":"2025/01/13/Hot100 记录/","permalink":"http://example.com/2025/01/13/Hot100%20%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Hot 100 刷题记录（1）滑动窗口套路 定长滑动窗口 总结成三步：入-更新-出。 入：下标为 i 的元素进入窗口，更新相关统计量。如果窗口左端点 i−k+1&lt;0，即 i&lt;k−1，则尚未形成第一个窗口，重复第一步。 更新：更新答案。一般是更新最大值&#x2F;最小值。 出：下标为 i−k+1 的元素离开窗口，更新相关统计量，为下一个循环做准备。 比如 123456for(int i = 0; i &lt; s.size(); ++i) &#123; if(uset.count(s[i])) cnt ++; // 入 res = std::max(res, cnt); // 更新答案 if(i &lt; k - 1) continue; if(uset.count(s[i - k + 1])) cnt --; // 出&#125; 不定长滑动窗口 越长越合法： 采取在 while 循环外更新答案 123456789for(...) &#123; umap[c] ++; // 入 while(umap[c] &gt; 1) &#123; // 合法性判断 umap[s[left]] --; // 出 left ++; &#125; // 更新 ans = std::max(ans, right - left + 1);&#125; 越短越合法： 采取在 while 循环内更新答案 12345678for(...) &#123; sum += nums[right]; // 入 while(sum &gt;= target) &#123; // 合法性判断 res = min(res, right - left + 1); // 更新 sum -= nums[left]; // 出 left ++; &#125;&#125; 求子数组个数：","categories":[{"name":"算法题","slug":"算法题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[]}],"categories":[{"name":"C++ 面经","slug":"C-面经","permalink":"http://example.com/categories/C-%E9%9D%A2%E7%BB%8F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"算法题","slug":"算法题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[]}