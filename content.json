{"meta":{"title":"Hexo","subtitle":"","description":"","author":"DxBlackSmith","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2026-01-13T09:57:44.000Z","updated":"2026-01-13T09:58:17.610Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2026-01-13T10:42:48.000Z","updated":"2026-01-13T10:46:21.352Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"烤面筋 Day 04","slug":"烤面筋_Day04","date":"2026-01-16T08:08:00.930Z","updated":"2026-01-16T08:33:32.151Z","comments":true,"path":"2026/01/16/烤面筋_Day04/","permalink":"http://example.com/2026/01/16/%E7%83%A4%E9%9D%A2%E7%AD%8B_Day04/","excerpt":"","text":"烤面筋 Day 04单例模式1. 单例模式是什么？有哪些单例模式？答：单例模式是一种设计模式，旨在确保一个类在整个应用程序的生命周期当中只有一个实例，提供一个全局访问点来获取该实例。 有一般的单例模式（用 static 修饰成员函数和 static 的局部变量），饿汉式单例模式，懒汉式单例模式，还有就是个人比较常用的 CRTP （声明单例的通用模板类） 2. 分别介绍一下这几种单例模式？ 一般单例模式：静态成员函数 + 静态局部变量 1234567891011121314class Singleton &#123;public: static Singleton&amp; GetInstance() &#123; // 静态局部变量只会被初始化一次 static Singleton instance; return instance; &#125; ~Singleton() = default;private: Singleton() = default; Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete;&#125;; 饿汉式单例模式：静态成员指针变量 + cpp 文件定义 1234567891011121314class Singleton &#123;public: ~Singleton() = default; static Singleton* GetInstance() &#123; if(instance == nullptr) instance = new Singleton(); return instance; &#125;private: static Singleton* instance; Singleton() = default; Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete;&#125;; 同时在 cpp 文件中定义 instance 实例 1Singleton* Singleton::instance = Singleton::GetInstance(); 懒汉式单例模式： 智能指针 + once_flag 12345678910111213141516171819202122#include &lt;mutex&gt;#include &lt;memory&gt;class Singleton &#123;public: ~Singleton() = default; static std::shared_ptr&lt;Singleton&gt; GetInstance() &#123; static std::once_flag flag; // flag 底层采用了原子性的原理，紧接的线程如果发现了 flag 已经被初始化， // 就不会执行 call_once 后面的可调用对象 std::call_once(flag, []()&#123; // 这里不能使用 std::make_shared 因为构造函数是私有的，外部作用域无法访问 instance = std::shared_ptr&lt;Singleton&gt;(new Singleton()); &#125;); return instance; &#125;private: static std::shared_ptr&lt;Singleton&gt; instance; Singleton() = default; Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete;&#125;; 3. CRTP 是什么？能不能实现一下？答：是一种将派生类作为模板参数传递给基类的技术，即一个类继承以自身为模板参数的基类。 基类代码： 123456789101112131415161718192021222324#include &lt;memory&gt;#include &lt;mutex&gt;template &lt;typename T&gt;class Singleton &#123;protected: Singleton() = default; Singleton(const Singleton&lt;T&gt;&amp; other) = delete; Singleton&amp; operator=(const Singleton&lt;T&gt;&amp; other) = delete; static std::shared_ptr&lt;T&gt; _instance;public: ~Singleton() = default; static std::shared_ptr&lt;T&gt; GetInstance() &#123; static std::once_flag flag; std::call_once(flag, [&amp;]()&#123; _instance = std::shared_ptr&lt;T&gt;(new T); &#125;); return _instance; &#125;&#125;;// 注意模板类的 static 一定要在头文件中定义template &lt;typename T&gt;std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = nullptr; 派生类代码： 1234567class SingleNet : public Singleton&lt;SingleNet&gt; &#123;private: SingleNet() = default; friend class Singleton&lt;SingleNet&gt;;public: ~SingleNet() = default;&#125;; 观察者模式1. 什么是观察者模式？答：观察者模式 是一种行为设计模式。它定义了对象间的一种 一对多 的依赖关系，使得每当一个对象状态发生改变时，所有依赖于它的对象都会得到通知并被自动更新。 2. 你觉得里面的重点是什么？ 解耦：被观察者（Subject）不需要知道观察者（Observer）的具体类，只需要知道它们实现了某个接口。 触发联动：状态改变自动触发行为，不需要轮询检查。 抽象依赖：Subject 依赖于 Observer 的抽象基类，符合开闭原则（对扩展开放，对修改关闭）。 3. 实现一下观察者模式吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;algorithm&gt;#include &lt;string&gt;// 1. 抽象观察者class Observer : public std::enable_shared_from_this&lt;Observer&gt; &#123;public: virtual ~Observer() = default; virtual void update(const std::string&amp; state) = 0;&#125;;// 2. 被观察者（Subject）class Subject &#123;public: // 线程安全的订阅：使用 weak_ptr 记录观察者 void attach(std::weak_ptr&lt;Observer&gt; observer) &#123; std::lock_guard&lt;std::mutex&gt; lock(_mtx); _observers.push_back(observer); &#125; // 状态更新并通知 void setState(std::string state) &#123; std::vector&lt;std::shared_ptr&lt;Observer&gt;&gt; active_observers; &#123; std::lock_guard&lt;std::mutex&gt; lock(_mtx); _state = state; // 遍历并检查生命周期 auto it = _observers.begin(); while (it != _observers.end()) &#123; // 尝试提升为 shared_ptr if (auto obj = it-&gt;lock()) &#123; active_observers.push_back(obj); ++it; &#125; else &#123; // 观察者已销毁，自动清理从列表中剔除 it = _observers.erase(it); &#125; &#125; &#125; // 在锁外进行通知，避免死锁风险及长时间占用锁 for (const auto&amp; obs : active_observers) &#123; obs-&gt;update(_state); &#125; &#125;private: std::string _state; std::vector&lt;std::weak_ptr&lt;Observer&gt;&gt; _observers; // 核心：弱引用 std::mutex _mtx; // 核心：互斥锁保证线程安全&#125;;// 3. 具体观察者示例class Worker : public Observer &#123;public: Worker(std::string name) : _name(name) &#123;&#125; void update(const std::string&amp; state) override &#123; std::cout &lt;&lt; &quot;Worker &quot; &lt;&lt; _name &lt;&lt; &quot; received: &quot; &lt;&lt; state &lt;&lt; std::endl; &#125;private: std::string _name;&#125;; Inline 内联函数1. 内联函数的实现机制？答：内联函数是向编译器发出的一个建议，请求将函数调用替换为函数体本身。 目的是消除函数调用的开销（如压栈、跳转、返回等），对于频繁调用的小函数性能提升明显。 2. 编译器一定会内联吗？答：不一定会内联。编译器会根据复杂的启发式算法自行决定。 如果函数过大或者过于复杂或者函数是虚函数（内联是编译时确定，虚函数是运行时确定的）的情况下，编译器会拒绝内联。同时现代的编译器非常聪明，即使没有写 inline 关键字，只要它认为有益且符合条件，也会自动进行优化内联","categories":[{"name":"C++ 面经","slug":"C-面经","permalink":"http://example.com/categories/C-%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"烤面筋 Day 03","slug":"烤面筋_Day03","date":"2026-01-15T16:08:37.654Z","updated":"2026-01-16T08:32:54.230Z","comments":true,"path":"2026/01/16/烤面筋_Day03/","permalink":"http://example.com/2026/01/16/%E7%83%A4%E9%9D%A2%E7%AD%8B_Day03/","excerpt":"","text":"烤面筋 Day 03多态与虚函数表：1. 多态的定义是什么？分类有哪些？答：多态是允许基类的指针或引用在运行时根据实际指向的子类对象类型，调用相应子类重写方法的能力。主要分为两类。 静态多态（编译时多态）：通过函数重载和模板实现。编译器在编译期间就确定了调用的函数版本。 动态多态（运行时多态）：通过虚函数（Virtual Function）和继承来时实现。程序在运行期间根据对象的实际类型来决定调用哪个函数。 2. 虚函数是什么？虚函数表和虚函数指针有什么用？答：虚函数是允许在派生类中被重写、并通过基类指针或引用实现运行时多态的函数。是实现动态多态的基石 虚函数表： 每个拥有虚函数的类都有一个虚表。它本质上是一个存放虚函数地址的数组。 虚函数指针： 每个具体的对象实例中都有一个隐藏指针，指向该类对应的虚函数表。 当通过基类指针调用虚函数时，程序先通过对象的虚指针找到虚函数表，再根据偏移量找到对应的函数地址并执行，从而实现动态绑定。即通过虚指针在运行时查找正确的函数实现。 3. 继承关系中的虚函数表是 “拷贝” 还是 “共享”？答：派生类会继承基类的虚函数表结构，但会生成一份属于自己的新表。 继承与拷贝： 派生类创建时，会首先拷贝基类的虚表内容到自己的新虚表中。 重写（Override）： 如果派生类重写了某个虚函数，编译器会用派生类自己的函数地址，**覆盖（Overwrite）**掉新虚表中原来基类的函数地址。 新增： 如果派生类定义了新的虚函数，这些地址会按顺序添加到新虚表的末尾。 结论： 基类和派生类拥有各自独立的虚函数表，互不干扰。 4. 下面的 B 对象占多大的内存空间？1234567891011121314151617181920class A &#123; char a; virtual void add1();&#125;class C &#123; char aa; virtual void add2();&#125;class B : public A, public C &#123; short a2; int a; short b; int c; char d; int sum(); virtual void add(); void add1(); void add2();&#125; 答：首先两个基础，创建一个 B 对象，这个对象的内存分布是怎么样的。构造一个派生类对象，它的内存布局里面肯定存在基类的子对象（以及其虚指针），如下图所示： ![image-20251029202359749](E:\\Document\\Garbage\\Typora Files\\image-20251029202359749-1768492539172-1.png) 图中的 vptr分别指向自己类的虚函数表，通常一个类的虚指针放在内存布局的最前面，所以这里 B 的虚指针一般会把 A 的虚指针给覆盖掉。 12构造一个子类对象：首先会先去构建基类的对象内容，比如这里的 A 和 C，然后再构造自己的内容。析构一个子类对象：和构造相反，先执行自己的析构函数，然后去执行基类的析构函数。 Question: 那这里有个问题，如果 A 的析构函数是虚函数的话，之前覆盖了 A 的虚指针，这里就找不到 A 的虚函数表，那么如何析构 A 的内容呢？ 答案就是编译器会在调用 B 的虚析构函数的时候，就把头部的虚指针重置为 A 的了，所以能够正常执行。 所以这里我们就明白了解决上面问题最重要的一个点，那就是 B 的内存空间一定会继承基类的虚指针以及基类的一些成员变量。 那么解决这个问题还需要明白一个知识点，那就是内存对齐。内存对齐的规则是什么呢？ 类的每个基准内存块大小 &#x3D; 类当中占用内存大小最大的成员变量的内存空间，比如这里的 A，虽然最大的成员变量是 1 字节，但是它存在虚函数，所以内部有虚指针。又由于虚指针是 8 字节，所以基准内存块大小就是 8 字节，所以这里 A 所占用是 8 + 8 &#x3D; 16 字节 每个类型的起始地址都是该类型大小的整数倍，比如 int 的成员变量，那么它的起始地址只有可能是 0, 4, 8, …. 明白了上面的两个点以后，现在我们来看这个问题： 首先由于 A 和 C 中存在虚函数（虚指针）的缘故，他们的大小都是 16 字节。然后我们看到 B 中自己的成员变量，首先 short 一定是在 4 字节的，因为 short 本身是占 2 字节的，但是由于对齐规则 2 ，后续跟进的 int 的起始地址只能是 4 的倍数，所以 2 - 4 的空间也是只能给 short ，这样的话就是 16 + 16 + 16，最后还有一个 char 类型，不过因为对齐规则 1，这里只能是也占用 8 个字节，所有总共占用的字节数是 16 + 16 + 16 + 8 &#x3D; 56 个字节。 智能指针1. 用过哪些智能指针？主要使用 C++ 11 引入的三种智能指针： std::unique_ptr：同一时间只能有一个指针持有资源，不可拷贝，只能 move。性能最高，无额外开销。 std::shared_ptr：共享指针，使用引用计数机制，允许多个指针指向同一资源。 std::weak_ptr：辅助指针，指向 shared_ptr 管理的对象但不增加引用计数，专门用于解决循环引用。 2. 实现一下 share_ptr ？3. 控制块里维护了什么？","categories":[{"name":"C++ 面经","slug":"C-面经","permalink":"http://example.com/categories/C-%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"烤面筋 Day 02","slug":"烤面筋_Day02","date":"2026-01-14T07:13:34.486Z","updated":"2026-01-15T09:16:59.819Z","comments":true,"path":"2026/01/14/烤面筋_Day02/","permalink":"http://example.com/2026/01/14/%E7%83%A4%E9%9D%A2%E7%AD%8B_Day02/","excerpt":"","text":"烤面筋 Day 02 类型转换1. 向上转型 vs 向下转型?这是多态中两个方向完全相反的操作： 向上转型： 定义：将子类的指针或引用转换成父类 安全性：绝对安全。因为子类也是一种父类 用法：这种转换是隐式，不需要显式调用 static_cast ，是实现多态的基础 向下转型： 定义：将父类的指针或引用转换为子类。 安全性： 不安全。父类对象不一定是子类。 用法：必须使用显式转换，出于安全保证使用 dynamic_cast 2. static_cast 与 dynamic_cast 的区别？本质区别在于 “转换发生的时机” 和 “安全检查的机制” static_cast： 在编译阶段完成，不进行运行时类型检查 主要用于基本类型转换（如 int 转 float），非多态层级结构内的指针&#x2F;引用转换。 dynamic_cast： 在运行阶段利用 RTTI（运行时类型信息） 检查转换是否合法 专门用于处理**多态（Polymorphism）**层级结构中的转换 3. static_cast 在什么场景有风险？static_cast 的风险主要发生在 向下转型（Downcasting），即把基类指针转换为派生类指针时： 风险点： 如果该基类指针实际上并没有指向那个派生类对象，static_cast 依然会强行转换成功，返回一个地址。 后果： 当你通过这个转换后的指针访问派生类特有的成员变量或虚函数时，会发生未定义行为（Undefined Behavior），通常表现为内存越界访问或程序崩溃，且这种错误在编译期无法察觉。 4. dynamic_cast 的优势是什么？它的核心优势是 “安全性”： 类型安全检查： 它会检查目标类型是否与对象的实际类型匹配。如果转换非法，对于指针会返回 nullptr，对于引用会抛出 std::bad_cast 异常。 支持虚继承转换： 在复杂的深层或菱形继承中，dynamic_cast 能够正确处理指针偏移。 Reactor + 线程池1. Reactor 模式是怎么实现的？Reactor 模式本质上是 “I&#x2F;O 复用 + 派发”，其核心组件包括： Event Demultiplexer：底层通常是 epoll或者 poll ，监听注册了的一堆文件描述符有哪些动静 Reactor：核心循环。通过多路分离器等待事件发生，一旦有事件（如可读、可写），就将其分发（Dispatch）给对应的 Handler。 Handlers：绑定在事件上的回调函数，负责非阻塞的读写操作。 2. 为什么采用主从 Reactor + 线程池？主要是为了解决单线程 Reactor 的性能瓶颈： 分工明确：Main Reactor 只负责监听连接（Accept），Sub Reactor 负责处理已连接套接字的 I&#x2F;O 事件。这避免了因为某个请求的 I&#x2F;O 耗时过长导致新连接无法进入。 充分利用多核： 多个 Sub Reactor 可以运行在不同的 CPU 核心上，并行处理 I&#x2F;O。 解耦计算：线程池 将业务计算逻辑从 I&#x2F;O 线程中剥离。如果业务逻辑耗时较长，它不会阻塞 I&#x2F;O 事件的分发，从而极大提高了系统的吞吐量。 Ps. 这里的 I&#x2F;O 线程处理的是 I&#x2F;O 读写，指的是从网卡驱动缓存拷贝到用户缓存区，或者将用户态数据拷贝到内核发送缓存区。业务计算逻辑则是加工数据（数据读上来以后，程序需要处理它），例如协议解析（二进制流解包成 Protobuf 或 JSON），数据库查询（根据请求差 SQL）等等 3. 从 Reactor 读到的数据如何传递给线程池？能不能实现一下？是通过任务队列来实现的。Sub Reactor 将 （数据，处理函数）封装成任务丢进队列，线程池里的 worker 线程通过竞争来获取任务。 线程安全的任务队列通常有使用条件变量的阻塞队列和无锁队列。 阻塞队列： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;template &lt;typename T&gt;class BlockQueue &#123;public: bool push(const T&amp; val) &#123; std::lock_guard lock(mtx_); if (stop_) return false; // 队列已停止，返回false que_.push(val); cv_.notify_one(); return true; &#125; bool pop(T&amp; val) &#123; std::unique_lock lock(mtx_); cv_.wait(lock, [this]()&#123; return stop_ || !que_.empty(); &#125;); if(stop_ &amp;&amp; que_.empty()) return false; val = que_.front(); que_.pop(); return true; &#125; void stop() &#123; &#123; std::lock_guard lock(mtx_); stop_ = true; &#125; cv_.notify_all(); &#125;private: std::condition_variable cv_; std::queue&lt;T&gt; que_; std::mutex mtx_; bool stop_ = false;&#125;; 无锁队列： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;atomic&gt;#include &lt;cstdio&gt;/** push: 先检查尾部的一致性, tail-&gt;next = new_node, tail = new_node（用 CAS 版本实现）* pop：先检查头部的一致性，如果队列为空 tail = tail-&gt;next, 不为空 head = head-&gt;next*/template &lt;typename T&gt;class LockFreeQueue &#123;public: LockFreeQueue(); ~LockFreeQueue(); void push(const T&amp; value) &#123; Node* newNode = new Node(value); while(true) &#123; Node* current_tail = tail.load(); Node* next = current_tail-&gt;next.load(); // 一致性检查 if(tail.load() == current_tail) &#123; // tail 是真正的尾部 if(next == nullptr) &#123; // 一致性检查 if(current_tail-&gt;next.compare_exchange_weak(next, newNode)) &#123; // 进行更新 tail.compare_exchange_weak(current_tail, newNode); return; &#125; &#125; else &#123; tail.compare_exchange_weak(current_tail, next); &#125; &#125; &#125; &#125; bool pop(T&amp; result) &#123; while(true) &#123; Node* current_head = head.load(); Node* current_tail = tail.load(); Node* next = current_head-&gt;next.load(); if(current_head == head.load()) &#123; // 队列有可能为空 if(current_head == current_tail) &#123; if(next == nullptr) return false; // 进行更新 tail = tail-&gt;next tail.compare_exchange_weak(current_tail, next); &#125; else &#123; result = next-&gt;data; if(head.compare_exchange_weak(current_head, next)) &#123; delete current_head; return true; &#125; &#125; &#125; &#125; &#125;private: struct Node &#123; T data; std::atomic&lt;Node*&gt; next; Node(const T&amp; val) : data(val), next(nullptr) &#123;&#125; &#125;; std::atomic&lt;Node*&gt; head; std::atomic&lt;Node*&gt; tail;&#125;; 4. CPU 密集型和 I&#x2F;O 密集型怎么判断？主要是看瓶颈在哪里：$N_{cpu}$ 是 CPU 核心数的意思 CPU 密集型： 特点：大部分时间在做复杂的运算（图像处理、科学计算） 判断： 程序运行时，CPU 占用率极高，但几乎没有磁盘或网络 I&#x2F;O。 线程池策略： 线程数通常设置为 $N_{CPU} + 1$。 I&#x2F;O 密集型： 特点： 大部分时间在等待磁盘读写、数据库查询、网络响应。 判断： CPU 占用率较低，系统大量时间处于等待状态（Wait）。 线程池策略： 线程数可以设置得大一些，如 $2N_{CPU}$ 甚至更多。 5. 线程池线程数如何确定？首先针对于 I&#x2F;O 密集型任务来说，一般设置为内核数 * 2。 当一个线程因为 I&#x2F;O 阻塞或等待时，CPU 可以切换到另一个线程。避免过多的上下文切换（Context Switch）带来的损耗。 不过在实际生产环境下，我会优先通过 压力测试 和 性能监控（如查看 top 中的 iowait 指标）来动态调整线程数，而不会死守 公式。 6. 手撕一下线程池？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;future&gt;#include &lt;functional&gt;#include &lt;atomic&gt;class ThreadPool &#123;private: std::vector&lt;std::thread&gt; workers; std::queue&lt;std::function&lt;void()&gt;&gt; tasks; std::mutex queue_mutex; std::condition_variable condition; std::atomic&lt;bool&gt; stop; public: ThreadPool(size_t num_threads = std::thread::hardware_concurrency()) : stop(false) &#123; for(size_t i = 0; i &lt; num_threads; ++i) &#123; workers.emplace_back([this] &#123; while(true) &#123; std::function&lt;void()&gt; task; &#123; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex); this-&gt;condition.wait(lock, [this] &#123; return this-&gt;stop || !this-&gt;tasks.empty(); &#125;); if(this-&gt;stop &amp;&amp; this-&gt;tasks.empty()) return; task = std::move(this-&gt;tasks.front()); this-&gt;tasks.pop(); &#125; task(); &#125; &#125;); &#125; &#125; ~ThreadPool() &#123; stop = true; condition.notify_all(); for(std::thread &amp;worker : workers) &#123; if(worker.joinable()) worker.join(); &#125; &#125; template&lt;class F, class... Args&gt; auto enqueue(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt; &#123; using return_type = typename std::result_of&lt;F(Args...)&gt;::type; auto task = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...) ); std::future&lt;return_type&gt; res = task-&gt;get_future(); &#123; std::unique_lock&lt;std::mutex&gt; lock(queue_mutex); if(stop) throw std::runtime_error(&quot;enqueue on stopped ThreadPool&quot;); tasks.emplace([task]()&#123; (*task)(); &#125;); &#125; condition.notify_one(); return res; &#125;&#125;;","categories":[{"name":"C++ 面经","slug":"C-面经","permalink":"http://example.com/categories/C-%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"烤面筋 Day 01","slug":"烤面筋_Day01","date":"2026-01-13T10:14:19.695Z","updated":"2026-01-14T07:11:17.577Z","comments":true,"path":"2026/01/13/烤面筋_Day01/","permalink":"http://example.com/2026/01/13/%E7%83%A4%E9%9D%A2%E7%AD%8B_Day01/","excerpt":"","text":"烤面筋 Day 01 原子操作与内存模型: 1. 原子操作是什么？Atomic 跟原子操作的关系是什么？答：原子操作就是要么不执行，要么全部执行成功，且中途不能被中断的操作。Atomic 就是 C++ 11 提供的标准库模板类，是原子操作在语言层面的封装和工具。 2. Atomic 底层是怎么实现的？答：底层主要依赖硬件层面处理器提供的原子指令，在 x86 架构下，通常会使用带有 LOCK 前缀的指令，其能锁定缓存行，确保执行执行期间不会被中断。 编译器层面也会根据不同的 CPU 架构，将 atomic 操作映射为相应的机器指令，根据指定的内存序，插入必要的 Memory Barrier ，防止指令重排。 3. 能简单讲讲 C++ 的内存序（Memory Order）吗？内存序的作用是约束编译器和 CPU 的指令重排优化，C++11 定义了 6 种内存序，但常用的是 memory_order_relaxed 和 获取&#x2F;释放语义和序列一致性。 宽松顺序：只保证当前操作的原子性，不保证任何顺序（没有同步关系）。 释放（release）语义：持有 release 的线程是发布者，，逻辑是 “做完手头的事情了，现在发布表示数据准备好了” 获取（acquire）语义：持有 acquire 的线程是获取者，逻辑是 “看到发布的通知了，说明我可以放心去用数据了” 序列一致性：atomic 的默认参数，要求所有线程看到的执行顺序都是一模一样的，就像所有操作都排在一个全局队列里依次执行。 那为什么不能全用默认的 seq_cst 序列一致性的内存序？ 高性能场景下（如无锁队列、底层驱动），默认的强顺序会导致大量的内存屏障指令，强制刷新 CPU 缓存，这会极大限制现代多核处理器的并行能力。 4. CAS 指令是什么？答：CAS 是实现原子操作的核心指令，包含三个操作数： 1231. 内存地址 V：要读取的变量位置。2. 旧的预期值 A：我们认为该变量当前应该是什么值。3. 准备写入的新值 B：如果检查通过，要更新成的值。 只有内存地址的值还是我之前读到的那个预期值，我才把它修改成新值。否则说明别人改过它，那我就放弃这次修改。整个过程是原子性的 5.CAS 的优缺点是什么？答：优点就是无锁，避免了传统互斥锁导致的线程上下文切换、挂起和恢复，性能开销更小。 缺点是有自旋开销，如果在高竞争环境下，CAS 一直失败，会导致 CPU 一直空转，浪费资源。同时还存在 ABA 问题。 6. ABA 问题是什么？如何解决这个问题？就是一个线程将数值 A 改成了 B，随后另一个线程又将 B 改回了 A，此时第三个线程进行检查，发现值依然是 A，认为没有改变，从而误操作。 目前解决的主流办法是版本号，实现方法就是记录值的同时维护一个版本号，每次更新的时候，不仅更新值，还让版本号 +1。这样遇到 ABA 问题的时候版本号不同，就知道值已经发生改变了。 7. C++ atomic 是否自带版本号机制？不自带。标准的 std::atomic 只是对类型 T 的原子封装。如果 T 是一个指针，仍然会存在 ABA 问题。 如果需要解决这个问题的话，开发者通常需要配合 std::atomic&lt;std::pair&lt;T, int&gt;&gt; 或者一些带有 Tag 的指针技术。 8. Volatile 关键字的作用是什么？能解决线程安全吗？主要的作用是禁止编译器优化：告诉编译器，这个变量的值可能随时被外部（如硬件中断、另一个进程）修改，因此每次使用它都必须从内存中读取，而不能使用寄存器里的缓存。 不能，因为他不保证原子性，同时不禁止指令重排，只针对编译器的，但不提供针对 CPU 的内存屏障，无法解决多核环境下的可见性和有序性问题。 9. 手撕一下：写一下 CAS 实现的无锁队列1234567891011121314151617181920212223242526272829303132333435#include &lt;atomic&gt;template &lt;typename T&gt;class LockFreeQueue &#123;public: void Enqueue(const T&amp; val) &#123; Node* new_node = Node(val); Node* old_tail = tail.load(); while(true) &#123; old_tail = tail.load(); Node* next = old_tail-&gt;next.load(); if(old_tail == tail.load()) &#123; if(next == nullptr) &#123; if(old_tail-&gt;next.compare_exchange_strong(next, new_node)) &#123; tail.compare_exchange_weak(old_tail, new_node); return; &#125; &#125; else tail.compare_exchange_strong(old_tail, next); &#125; &#125; &#125;private: struct Node &#123; T data; std::atomic&lt;Node*&gt; next; Node(T val) : data(val), next(nullptr) &#123;&#125; &#125;; std::atomic&lt;Node*&gt; head; std::atomic&lt;Node*&gt; tail;&#125;;int main(int argc, char* argv[]) &#123;&#125; 多线程与锁 1. 多线程最常见的问题是什么？主要是三个问题： 线程安全问题：多个线程同时读写同一个块内存，导致结果不可预期 活跃性问题：包括死锁，活锁和饥饿，其中死锁是最致命的，会导致程序完全卡死 性能开销：过渡的上下文切换和锁竞争导致性能下降 2. 死锁怎么避免？避免死锁的核心逻辑是：防止循环等待链的形成。常用的解决办法如下： 固定加锁顺序：规定所有的线程必须按照相同的顺序获取锁（先拿 A 锁，再拿 B 锁） 尝试锁（Try-lock）：使用 std::unique_lock 的 try_lock，如果拿不到锁就立即释放已占用的所并且回退 使用高级抽象：使用其他无锁的机制（比如消息传递等等）来替代底层锁 3. 哪些设计方式&#x2F;技巧能破坏死锁的 4 个条件？互斥性：资源一次只能被一个线程占用。这个是无法破坏（锁的本意）。 占用且等待：线程持有一个资源的同时，还在等待另一个资源。采用一次性申请的方式解决： 线程启动前一次性申请所有需要的锁；或者在无法获取下一个锁时，释放已占有的所有锁。 不可剥夺：资源不能被抢占，只能由持有者主动释放。采用抢占机制的方式解决：如果线程申请新锁失败，主动释放手中资源，过段时间再重试 循环等待：存在一个线程等待环路：T1 等 T2，T2 等 T1。采用资源线性排序的方式解决： 给所有锁分配唯一序号，强制规定必须按序号从小到大（或从大到小）获取锁。 4. 实际开发中，你会如何实现避免死锁的发生？我会使用 std::scoped_lock 一次性添加多个锁利用其内部的机制来避免 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;thread&gt;class Account &#123;public: int balance = 1000; std::mutex mtx; // 每个账户自带一把锁&#125;;void transfer(Account&amp; from, Account&amp; to, int amount) &#123; // 关键点：std::scoped_lock 同时接收多个 mutex // 它内部使用了一种免死锁算法（通常是逐个尝试且不持有等待） // 无论你传入参数的顺序如何，它都能保证不会发生死锁 std::scoped_lock lock(from.mtx, to.mtx); if (from.balance &gt;= amount) &#123; from.balance -= amount; to.balance += amount; std::cout &lt;&lt; &quot;转账成功: &quot; &lt;&lt; amount &lt;&lt; std::endl; &#125;&#125;int main() &#123; Account alice, bob; // 线程 1：从 Alice 转账给 Bob std::thread t1(transfer, std::ref(alice), std::ref(bob), 100); // 线程 2：从 Bob 转账给 Alice (如果用普通 lock 会因顺序相反导致死锁) std::thread t2(transfer, std::ref(bob), std::ref(alice), 200); t1.join(); t2.join(); return 0;&#125; 其内部的机制 避免循环等待：内部并不简单地按顺序调用 lock()，而是采用了一种 “重试机制”： ​ 1. 它会尝试锁住第一个互斥量。 ​ 2. 接着尝试 try_lock 后面的互斥量。 ​ 3. 如果中间任何一个锁失败了，它会立即释放已经持有的所有锁，然后重新开始。 原子性加锁：保证了所有传入的互斥量要么全部锁住，要么一个都不锁。","categories":[{"name":"C++ 面经","slug":"C-面经","permalink":"http://example.com/categories/C-%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"NetWork","slug":"NetWork","date":"2025-12-07T05:09:21.000Z","updated":"2026-01-13T10:47:08.037Z","comments":true,"path":"2025/12/07/NetWork/","permalink":"http://example.com/2025/12/07/NetWork/","excerpt":"","text":"“连网”平时我们说的连网，连网到底是什么呢？为什么实验室的主机只能接网线或者连接 wifi 才能访问互联网上的各种资源呢？ 为了搞清楚这个问题，需要搞懂下面几个概念 连网：主机通过有线或无线方式接入网络，获得 IP 地址，并能够与其他设备或互联网进行数据通信的过程。 主机网络通信的方法公网通信两台主机都有公网 IP, 可以直接通过 ssh user@公网 IP 连接 这种通常只适用于具有固定公网 IP 的设备连接。 家庭的宽带通常是动态的公网 IP (重启光猫以后会变化)，企业或者云服务器才是静态公网 IP 。 解释家里为什么只有连接 wifi （连接路由器）才能访问互联网上的各种资源。 只要是需要访问互联网上的资源，那么都需要设备具有公网 IP， 但是手机等设备出厂时只有 mac 地址，连接路由器的才会给你分配 IP 地址（IP 地址是逻辑地址，由网络环境决定的），但是就算给你分配了，也只是内网 IP，路由器才是唯一具有公网 IP 的设备。 不过连接的路由器会将你的内网 IP 结合自己的 WAN 口（公网 IP）转换成公网 IP，收到回复包的时候，又将这个公网 IP 转换成内网 IP 从而找到你的设备，这其中牵扯到的协议叫做 NAT 协议，这里先不仔细讲了，大概是实现了地址转换的意思。 Ps. 用 4G/5G 是不经过家用路由器，直接通过基站连接到运营商的核心网，然后运营商给你分配 CGNAT IP&#x2F; 公网 IP 。 局域网通信同一局域网内通信在同一局域网下面，通过局域网的 IP 能够直接进行通信。这个用的比较多，一般公司&#x2F;学校&#x2F;实验室内部服务器都是通过这种方式。 那么有些时候为了固定比如监控摄像头和打印机的 IP 或者实验室根本就没有路由器（纯内网通信），这个时候作为计算机专业的我们，可能会让我们配置静态 IP。 于是就会接触下面的概念： 子网掩码：用于划分网络地址和主机地址。同一局域网的所有 IP &amp; 上这个掩码都会得到同一个地址（一般就填 255.255.255.0 ） 默认网关：当访问不是局域网的地址的时候，数据包就会发给网关。通常是路由器的内网 IP ，大多数默认网关的 IP 地址的最后一位是 1 或者 254（0 不可以，255 用作广播） DNS 服务器：用于将输入的域名解析成 IP 地址，比较方便。DNS 服务器通常填 114.114.114.114 这种公共 DNS 服务器即可 在纯内网通信（实验室中常用）当中，交换机由于没有 DHCP 服务器，就没有自动分配 IP 的功能（路由器有），所以这个时候只能通过手动配置 IP 的方式来实现通信。 这个时候只需要所有的机器都在同一个网段，比如 12345678910IP: 不冲突就行 机器 A : 192.168.10.10 机器 B : 192.168.10.11 机器 B : 192.168.10.12 子网掩码： 统一填 255.255.255.0 默认网关: 一般留空（0.0.0.0)，因为一般不需要上网DNS： 一般也留空，除非你要解析域名，但是一般内网用 IP 地址 如何配置一个新设备的静态 IP 记录同网段下另一台配置好得设备的网段 （IP + 子网掩码 192.168.31.0&#x2F;24）和默认网关（ 192.168.31.1） 选择一个不冲突的静态 IP（ping 一下看看连不连通），登录设备的管理界面，这个一般根据设备的不同有些许不同，可以查看下表： 设备类型 登录方式 打印机 1. 在打印机面板上查看 IP 2. 用浏览器访问该 IP 3. 输入管理员账号密码（默认常印在机身） 交换机（网管型） 1. 用 Console 线（串口）连接电脑 2. 用终端软件（PuTTY、SecureCRT）登录 摄像头 &#x2F; NAS 浏览器访问 IP 或专用客户端 Linux 服务器 SSH 登录后修改网络配置文件 配置 IP 参数（一般内网就配置 IP 地址和子网掩码就可以）同时保存验证，比如用新 IP 能够重新访问设备的管理界面和用其他设备 ping 一下这个设备来测试连通。 不同局域网之间通信 通过跳板机中转 跳板机：一个专门用于中转访问内网资源的 “堡垒” 服务器，一般用于集中管理访问权限。 比如公司的数据库服务器，或者内部的 API 服务部署在私有网络中，处于安全考虑不允许直接暴露到互联网中。所以他们没有公网 IP，同时又不可能和你在一个局域网内，这个时候就需要先登录一台有公网 IP 的跳板机，再从它跳转过去。 这样目标服务器就实现了完全隔离，其防火墙只允许跳板机 IP 访问 SSH 端口。 那么我们如何能够通过跳板机来连接目标服务器呢？ 最推荐的就是直接编辑本地电脑的 SSH 配置文件（~&#x2F;.ssh&#x2F;config 文件）。假如我们有如下信息 角色 信息 跳板机 公网 IP: 203.0.113.10，用户名: abc，SSH 端口: 22 目标服务器 内网 IP: 10.0.1.20，用户名: cba 那么直接在配置文件中定义如下即可： 1234567891011# 跳板机定义Host jump HostName 203.0.113.10 User ops Port 22# 目标服务器（通过跳板机访问）Host db-server HostName 10.0.1.20 User app ProxyJump jump vscode 下载相应的插件以后读取这个配置，就能直接连接内部服务器，实现代码编辑和文件上传（vscode 内置的 SFTP ）。也有人用 xftp 或者 Filezilla 来实现文件传输，我没用过，所以暂时不评论。 Ps. vscode 具体操作就是调出命令面板，remote-ssh: connet to host。 内网穿透 这个暂时没有接触到，先挖个坑。。。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"Hot 100 刷题记录","slug":"Hot100 记录","date":"2025-01-13T10:05:08.000Z","updated":"2026-01-15T16:09:31.143Z","comments":true,"path":"2025/01/13/Hot100 记录/","permalink":"http://example.com/2025/01/13/Hot100%20%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Hot 100 刷题记录（1）滑动窗口套路 定长滑动窗口 总结成三步：入-更新-出。 入：下标为 i 的元素进入窗口，更新相关统计量。如果窗口左端点 i−k+1&lt;0，即 i&lt;k−1，则尚未形成第一个窗口，重复第一步。 更新：更新答案。一般是更新最大值&#x2F;最小值。 出：下标为 i−k+1 的元素离开窗口，更新相关统计量，为下一个循环做准备。 比如 123456for(int i = 0; i &lt; s.size(); ++i) &#123; if(uset.count(s[i])) cnt ++; // 入 res = std::max(res, cnt); // 更新答案 if(i &lt; k - 1) continue; if(uset.count(s[i - k + 1])) cnt --; // 出&#125; 不定长滑动窗口 越长越合法： 采取在 while 循环外更新答案 123456789for(...) &#123; umap[c] ++; // 入 while(umap[c] &gt; 1) &#123; // 合法性判断 umap[s[left]] --; // 出 left ++; &#125; // 更新 ans = std::max(ans, right - left + 1);&#125; 越短越合法： 采取在 while 循环内更新答案 12345678for(...) &#123; sum += nums[right]; // 入 while(sum &gt;= target) &#123; // 合法性判断 res = min(res, right - left + 1); // 更新 sum -= nums[left]; // 出 left ++; &#125;&#125; 求子数组个数： 1暂时还没刷到","categories":[{"name":"算法题","slug":"算法题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[]}],"categories":[{"name":"C++ 面经","slug":"C-面经","permalink":"http://example.com/categories/C-%E9%9D%A2%E7%BB%8F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"算法题","slug":"算法题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[]}