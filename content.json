{"meta":{"title":"Hexo","subtitle":"","description":"","author":"DxBlackSmith","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2026-01-13T09:57:44.000Z","updated":"2026-01-13T09:58:17.610Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2026-01-13T10:42:48.000Z","updated":"2026-01-13T10:46:21.352Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"烤面筋 Day 01","slug":"烤面筋_Day01","date":"2026-01-13T10:14:19.695Z","updated":"2026-01-13T10:47:38.392Z","comments":true,"path":"2026/01/13/烤面筋_Day01/","permalink":"http://example.com/2026/01/13/%E7%83%A4%E9%9D%A2%E7%AD%8B_Day01/","excerpt":"","text":"烤面筋 Day 01 原子操作与内存模型:1. 原子操作是什么？Atomic 跟原子操作的关系是什么？答：原子操作就是要么不执行，要么全部执行成功，且中途不能被中断的操作。Atomic 就是 C++ 11 提供的标准库模板类，是原子操作在语言层面的封装和工具。 2. Atomic 底层是怎么实现的？答：底层主要依赖硬件层面处理器提供的原子指令，在 x86 架构下，通常会使用带有 LOCK 前缀的指令，其能锁定缓存行，确保执行执行期间不会被中断。 编译器层面也会根据不同的 CPU 架构，将 atomic 操作映射为相应的机器指令，根据指定的内存序，插入必要的 Memory Barrier ，防止指令重排。 3. 能简单讲讲 C++ 的内存序（Memory Order）吗？内存序的作用是约束编译器和 CPU 的指令重排优化，C++11 定义了 6 种内存序，但常用的是 memory_order_relaxed 和 获取&#x2F;释放语义和序列一致性。 宽松顺序：只保证当前操作的原子性，不保证任何顺序（没有同步关系）。 释放语义：保证在此之前的读写操作绝不能重排到此操作之后。就像在代码里打了一个“禁止向下越界”的标记。 获取语义：保证在此之后的读写操作绝不能重排到此操作之前。就像打了一个“禁止向上越界”的标记（保证线程间的逻辑先后顺序（同步））。 序列一致性：atomic 的默认参数，要求所有线程看到的执行顺序都是一模一样的，就像所有操作都排在一个全局队列里依次执行。 那为什么不能全用默认的 seq_cst 序列一致性的内存序？ 高性能场景下（如无锁队列、底层驱动），默认的强顺序会导致大量的内存屏障指令，强制刷新 CPU 缓存，这会极大限制现代多核处理器的并行能力。 4. CAS 指令是什么？答：CAS 是实现原子操作的核心指令，包含三个操作数： 1231. 内存地址 V：要读取的变量位置。2. 旧的预期值 A：我们认为该变量当前应该是什么值。3. 准备写入的新值 B：如果检查通过，要更新成的值。 只有内存地址的值还是我之前读到的那个预期值，我才把它修改成新值。否则说明别人改过它，那我就放弃这次修改。整个过程是原子性的 5.CAS 的优缺点是什么？答：优点就是无锁，避免了传统互斥锁导致的线程上下文切换、挂起和恢复，性能开销更小。 缺点是有自旋开销，如果在高竞争环境下，CAS 一直失败，会导致 CPU 一直空转，浪费资源。同时还存在 ABA 问题。 6. ABA 问题是什么？如何解决这个问题？就是一个线程将数值 A 改成了 B，随后另一个线程又将 B 改回了 A，此时第三个线程进行检查，发现值依然是 A，认为没有改变，从而误操作。 目前解决的主流办法是版本号，实现方法就是记录值的同时维护一个版本号，每次更新的时候，不仅更新值，还让版本号 +1。这样遇到 ABA 问题的时候版本号不同，就知道值已经发生改变了。 7. C++ atomic 是否自带版本号机制？不自带。标准的 std::atomic 只是对类型 T 的原子封装。如果 T 是一个指针，仍然会存在 ABA 问题。 如果需要解决这个问题的话，开发者通常需要配合 std::atomic&lt;std::pair&lt;T, int&gt;&gt; 或者一些带有 Tag 的指针技术。 8. Volatile 关键字的作用是什么？能解决线程安全吗？主要的作用是禁止编译器优化：告诉编译器，这个变量的值可能随时被外部（如硬件中断、另一个进程）修改，因此每次使用它都必须从内存中读取，而不能使用寄存器里的缓存。 不能，因为他不保证原子性，同时不禁止指令重排，只针对编译器的，但不提供针对 CPU 的内存屏障，无法解决多核环境下的可见性和有序性问题。 9. 手撕一下：写一下 CAS 实现的无锁队列","categories":[{"name":"C++ 面经","slug":"C-面经","permalink":"http://example.com/categories/C-%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"NetWork","slug":"NetWork","date":"2025-12-07T05:09:21.000Z","updated":"2026-01-13T10:47:08.037Z","comments":true,"path":"2025/12/07/NetWork/","permalink":"http://example.com/2025/12/07/NetWork/","excerpt":"","text":"“连网”平时我们说的连网，连网到底是什么呢？为什么实验室的主机只能接网线或者连接 wifi 才能访问互联网上的各种资源呢？ 为了搞清楚这个问题，需要搞懂下面几个概念 连网：主机通过有线或无线方式接入网络，获得 IP 地址，并能够与其他设备或互联网进行数据通信的过程。 主机网络通信的方法公网通信两台主机都有公网 IP, 可以直接通过 ssh user@公网 IP 连接 这种通常只适用于具有固定公网 IP 的设备连接。 家庭的宽带通常是动态的公网 IP (重启光猫以后会变化)，企业或者云服务器才是静态公网 IP 。 解释家里为什么只有连接 wifi （连接路由器）才能访问互联网上的各种资源。 只要是需要访问互联网上的资源，那么都需要设备具有公网 IP， 但是手机等设备出厂时只有 mac 地址，连接路由器的才会给你分配 IP 地址（IP 地址是逻辑地址，由网络环境决定的），但是就算给你分配了，也只是内网 IP，路由器才是唯一具有公网 IP 的设备。 不过连接的路由器会将你的内网 IP 结合自己的 WAN 口（公网 IP）转换成公网 IP，收到回复包的时候，又将这个公网 IP 转换成内网 IP 从而找到你的设备，这其中牵扯到的协议叫做 NAT 协议，这里先不仔细讲了，大概是实现了地址转换的意思。 Ps. 用 4G/5G 是不经过家用路由器，直接通过基站连接到运营商的核心网，然后运营商给你分配 CGNAT IP&#x2F; 公网 IP 。 局域网通信同一局域网内通信在同一局域网下面，通过局域网的 IP 能够直接进行通信。这个用的比较多，一般公司&#x2F;学校&#x2F;实验室内部服务器都是通过这种方式。 那么有些时候为了固定比如监控摄像头和打印机的 IP 或者实验室根本就没有路由器（纯内网通信），这个时候作为计算机专业的我们，可能会让我们配置静态 IP。 于是就会接触下面的概念： 子网掩码：用于划分网络地址和主机地址。同一局域网的所有 IP &amp; 上这个掩码都会得到同一个地址（一般就填 255.255.255.0 ） 默认网关：当访问不是局域网的地址的时候，数据包就会发给网关。通常是路由器的内网 IP ，大多数默认网关的 IP 地址的最后一位是 1 或者 254（0 不可以，255 用作广播） DNS 服务器：用于将输入的域名解析成 IP 地址，比较方便。DNS 服务器通常填 114.114.114.114 这种公共 DNS 服务器即可 在纯内网通信（实验室中常用）当中，交换机由于没有 DHCP 服务器，就没有自动分配 IP 的功能（路由器有），所以这个时候只能通过手动配置 IP 的方式来实现通信。 这个时候只需要所有的机器都在同一个网段，比如 12345678910IP: 不冲突就行 机器 A : 192.168.10.10 机器 B : 192.168.10.11 机器 B : 192.168.10.12 子网掩码： 统一填 255.255.255.0 默认网关: 一般留空（0.0.0.0)，因为一般不需要上网DNS： 一般也留空，除非你要解析域名，但是一般内网用 IP 地址 如何配置一个新设备的静态 IP 记录同网段下另一台配置好得设备的网段 （IP + 子网掩码 192.168.31.0&#x2F;24）和默认网关（ 192.168.31.1） 选择一个不冲突的静态 IP（ping 一下看看连不连通），登录设备的管理界面，这个一般根据设备的不同有些许不同，可以查看下表： 设备类型 登录方式 打印机 1. 在打印机面板上查看 IP 2. 用浏览器访问该 IP 3. 输入管理员账号密码（默认常印在机身） 交换机（网管型） 1. 用 Console 线（串口）连接电脑 2. 用终端软件（PuTTY、SecureCRT）登录 摄像头 &#x2F; NAS 浏览器访问 IP 或专用客户端 Linux 服务器 SSH 登录后修改网络配置文件 配置 IP 参数（一般内网就配置 IP 地址和子网掩码就可以）同时保存验证，比如用新 IP 能够重新访问设备的管理界面和用其他设备 ping 一下这个设备来测试连通。 不同局域网之间通信 通过跳板机中转 跳板机：一个专门用于中转访问内网资源的 “堡垒” 服务器，一般用于集中管理访问权限。 比如公司的数据库服务器，或者内部的 API 服务部署在私有网络中，处于安全考虑不允许直接暴露到互联网中。所以他们没有公网 IP，同时又不可能和你在一个局域网内，这个时候就需要先登录一台有公网 IP 的跳板机，再从它跳转过去。 这样目标服务器就实现了完全隔离，其防火墙只允许跳板机 IP 访问 SSH 端口。 那么我们如何能够通过跳板机来连接目标服务器呢？ 最推荐的就是直接编辑本地电脑的 SSH 配置文件（~&#x2F;.ssh&#x2F;config 文件）。假如我们有如下信息 角色 信息 跳板机 公网 IP: 203.0.113.10，用户名: abc，SSH 端口: 22 目标服务器 内网 IP: 10.0.1.20，用户名: cba 那么直接在配置文件中定义如下即可： 1234567891011# 跳板机定义Host jump HostName 203.0.113.10 User ops Port 22# 目标服务器（通过跳板机访问）Host db-server HostName 10.0.1.20 User app ProxyJump jump vscode 下载相应的插件以后读取这个配置，就能直接连接内部服务器，实现代码编辑和文件上传（vscode 内置的 SFTP ）。也有人用 xftp 或者 Filezilla 来实现文件传输，我没用过，所以暂时不评论。 Ps. vscode 具体操作就是调出命令面板，remote-ssh: connet to host。 内网穿透 这个暂时没有接触到，先挖个坑。。。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"Hot 100 刷题记录","slug":"Hot100 记录","date":"2025-01-13T10:05:08.000Z","updated":"2026-01-13T10:47:24.358Z","comments":true,"path":"2025/01/13/Hot100 记录/","permalink":"http://example.com/2025/01/13/Hot100%20%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Hot 100 刷题记录（1）滑动窗口套路 定长滑动窗口 总结成三步：入-更新-出。 入：下标为 i 的元素进入窗口，更新相关统计量。如果窗口左端点 i−k+1&lt;0，即 i&lt;k−1，则尚未形成第一个窗口，重复第一步。 更新：更新答案。一般是更新最大值&#x2F;最小值。 出：下标为 i−k+1 的元素离开窗口，更新相关统计量，为下一个循环做准备。 比如 123456for(int i = 0; i &lt; s.size(); ++i) &#123; if(uset.count(s[i])) cnt ++; // 入 res = std::max(res, cnt); // 更新答案 if(i &lt; k - 1) continue; if(uset.count(s[i - k + 1])) cnt --; // 出&#125; 不定长滑动窗口 越长越合法： 采取在 while 循环外更新答案 123456789for(...) &#123; umap[c] ++; // 入 while(umap[c] &gt; 1) &#123; // 合法性判断 umap[s[left]] --; // 出 left ++; &#125; // 更新 ans = std::max(ans, right - left + 1);&#125; 越短越合法： 采取在 while 循环内更新答案 12345678for(...) &#123; sum += nums[right]; // 入 while(sum &gt;= target) &#123; // 合法性判断 res = min(res, right - left + 1); // 更新 sum -= nums[left]; // 出 left ++; &#125;&#125; 求子数组个数：","categories":[{"name":"算法题","slug":"算法题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[]}],"categories":[{"name":"C++ 面经","slug":"C-面经","permalink":"http://example.com/categories/C-%E9%9D%A2%E7%BB%8F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"算法题","slug":"算法题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[]}